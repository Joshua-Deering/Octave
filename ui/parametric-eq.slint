import { Button } from "std-widgets.slint";

export struct NodeData {
    gain: float,
    freq: float,
    q: float,
}

export struct FreqResponse {
    freq: float,
    gain: float,
}

export component ParametricEq {

    pure callback initialize_eq_nodes(int, int, int) -> [NodeData];
    pure callback request_eq_response([NodeData], float, float, float, float, length, length) -> image;

    width: 100%;
    height: 100%;

    property <float> min_freq: 20;
    property <float> max_freq: 20000;
    property <float> min_gain: -20;
    property <float> max_gain: 20;

    property <length> node_rad: 8px;

    in property <int> num_nodes: 5;
    property <[NodeData]> eq_nodes: initialize_eq_nodes(self.num_nodes, min_freq, max_freq);

    property <int> hovered_node;
    property <length> hovered_node_x;
    property <length> hovered_node_y;

    property <image> eq_graph;

    changed num_nodes => {
        self.eq_nodes = initialize_eq_nodes(self.num_nodes, min_freq, max_freq);
    }
    VerticalLayout {
        drawing_area := Rectangle {
            height: 80%;
            background: darkblue;
            Image {
                source: eq_graph;
            }
            for node[i] in eq_nodes: Rectangle {
                property <bool> has_hover: is_inside(self.x + root.node_rad, self.y + root.node_rad, peq_ta.mouse-x, peq_ta.mouse-y, root.node_rad);

                x: root.node_to_x(node, parent.x, parent.width, root.min_freq, root.max_freq) - root.node_rad;
                y: root.node_to_y(node, parent.y, parent.height, root.min_gain, root.max_gain) - root.node_rad;

                width: 2 * root.node_rad;
                height: 2 * root.node_rad;

                border-radius: root.node_rad;
                border-width: 1px;
                border-color: has_hover ? blue : white;

                changed has_hover => {
                    if (self.has_hover == true) {
                        root.hovered_node = i;
                        root.hovered_node_x = self.x + root.node_rad;
                        root.hovered_node_y = self.y + root.node_rad;
                    }
                }
            }
            peq_ta := TouchArea {
                moved => {
                    if (is_inside(hovered_node_x, hovered_node_y, self.mouse-x, self.mouse-y, root.node_rad)) {
                        root.eq_nodes[hovered_node].freq = x_to_freq(self.mouse-x, parent.x, parent.width, root.min_freq, root.max_freq);
                        root.eq_nodes[hovered_node].gain = y_to_gain(self.mouse-y, parent.y, parent.height, root.min_gain, root.max_gain);
                        hovered_node_x = self.mouse-x;
                        hovered_node_y = self.mouse-y;
                    }
                }
            }
            
            Button {
                x: root.x + root.width - self.width - 3px;
                y: root.y + root.height * 0.8 - self.height - 3px;
                text: "Set Eq Curve";
                clicked => {
                    root.eq_graph = request_eq_response(root.eq_nodes, root.min_freq, root.max_freq, root.min_gain, root.max_gain, root.width, root.height * 0.8);
                }
            }
        }

        Rectangle {
            background: green;
            HorizontalLayout {
                spacing: 8px;
                alignment: center;
                for node[i] in eq_nodes: Rectangle {
                    border-radius: 10px;
                    background: blue;
                    width: root.width / 5 - 8px;
                    height: 20%;
                    Text {
                        text: i + 1;
                        x: (root.x / 5) * i + 5px;
                        y: parent.y + 5px;
                    }

                    HorizontalLayout {
                        alignment: center;
                        width: 100%;
                        height: 100%;
                        VerticalLayout {
                            padding-top: 3px;
                            Text {
                                text: "Gain: " + node.gain;
                            }

                            Text {
                                text: "Freq: " + node.freq;
                            }

                            Text {
                                text: "Q: " + node.q;
                            }
                        }
                    }
                }
            }
        }
    }

    pure function is_inside(
        c_x: length, c_y: length, 
        m_x: length, m_y: length,
        r: length
    ) -> bool {
        (Math.pow((c_x - m_x) / 1px, 2) + Math.pow((c_y - m_y) / 1px, 2)) <= Math.pow(r / 1px, 2)
    }

    pure function node_to_x(
        node: NodeData,
        parent_x: length, parent_w: length,
        min_freq: float, max_freq: float
    ) -> length {
        parent_x + ((log(node.freq, 10)-log(min_freq, 10))/(log(max_freq, 10)-log(min_freq, 10))) * parent_w;
    }

    pure function x_to_freq(
        x: length,
        parent_x: length, parent_w: length,
        min_freq: float, max_freq: float
    ) -> float {
        Math.pow(10, log(min_freq, 10) + ((x - parent_x) / parent_w) * (log(max_freq, 10) - log(min_freq, 10)))
    }

    pure function node_to_y(
        node: NodeData,
        parent_y: length, parent_h: length,
        min_gain: float, max_gain: float,
    ) -> length {
        if (node.gain > 0.0) {
            return ((parent_y + parent_h / 2) - (log(1 + node.gain, 10) / log(1 + max_gain, 10)) * parent_h / 2);
        } else if (node.gain < 0.0) {
            return ((parent_y + parent_h / 2) + (log(1 - node.gain, 10) / log(1 + max_gain, 10)) * parent_h / 2);
        } else {
            return (parent_y + parent_h / 2);
        }
    }

    pure function y_to_gain(
        y: length,
        parent_y: length, parent_h: length,
        min_gain: float, max_gain: float,
    ) -> float {
        if (y < parent_y + parent_h / 2) {
            return Math.pow(10, ((parent_y + parent_h / 2 - y) / (parent_h / 2)) * log(1 + max_gain, 10)) - 1;
        } else if (y > parent_y + parent_h / 2) {
            return -(Math.pow(10, ((y - (parent_y + parent_h / 2)) / (parent_h / 2)) * log(1 - min_gain, 10)) - 1);
        } else {
            return (parent_y + parent_h / 2) / 1px;
        }
        0.0
    }

}
